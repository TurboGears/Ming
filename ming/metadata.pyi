from bson import ObjectId
from datetime import datetime
from typing import Generic, TypeVar, Any, Optional, overload, List, Dict, Type, Union, Mapping, type_check_only

import bson
from ming.base import Cursor

from . import schema
from .base import Object


AnyType = TypeVar('AnyType')


@type_check_only
class DeprecatedField:
    YOU_SHOULDNT_USE_THIS = ...


# if https://youtrack.jetbrains.com/issue/PY-26184 is implemented, we could do a more technically "correct" type definition
# using descriptors, but the above __new__ overloads are working quite well, at least for pycharm (not sure about mypy)
#def __get__(self, instance: Any, owner: Any) -> FT: ...

# none of these seem to work, so instead using @overload with every type explicitly.  Which does work quite well
# FT = TypeVar('FT', str, datetime, SchemaItem, List, Dict)
# FT = TypeVar('FT', bound=SchemaItem)
# FT = TypeVar('FT', bound=type)
# FT = TypeVar('FT', int, str, float, bool, datetime)  # see SHORTHAND
# class Field(Generic[FT]):
    # @overload
    # def __new__(cls, type_: FT, **kwargs) -> FT: ...

class Field:
    # see ming.schema.SchemaItem.make() docstring

    # main types like:
    #  Field(str)
    #  Field(S.String)
    #  Field(S.String(if_missing=''))
    @overload
    def __new__(cls, type_: Type[schema.String], **kwargs) -> str: ...
    @overload
    def __new__(cls, type_: schema.String, **kwargs) -> str: ...
    @overload
    def __new__(cls, type_: Type[str], **kwargs) -> str: ...
    @overload
    def __new__(cls, type_: Type[schema.Int], **kwargs) -> int: ...
    @overload
    def __new__(cls, type_: schema.Int, **kwargs) -> int: ...
    @overload
    def __new__(cls, type_: Type[int], **kwargs) -> int: ...
    @overload
    def __new__(cls, type_: Type[schema.Float], **kwargs) -> Union[int, float]: ...
    @overload
    def __new__(cls, type_: schema.Float, **kwargs) -> Union[int, float]: ...
    @overload
    def __new__(cls, type_: Type[float], **kwargs) -> float: ...
    @overload
    def __new__(cls, type_: Type[schema.DateTimeTZ], **kwargs) -> datetime: ...
    @overload
    def __new__(cls, type_: schema.DateTimeTZ, **kwargs) -> datetime: ...
    @overload
    def __new__(cls, type_: Type[datetime], **kwargs) -> datetime: ...
    @overload
    def __new__(cls, type_: Type[schema.Bool], **kwargs) -> bool: ...
    @overload
    def __new__(cls, type_: schema.Bool, **kwargs) -> bool: ...
    @overload
    def __new__(cls, type_: Type[bool], **kwargs) -> bool: ...

    # special
    @overload
    def __new__(cls, type_: Type[schema.Binary], **kwargs) -> Union[bson.Binary, bytes]: ...
    @overload
    def __new__(cls, type_: schema.Binary, **kwargs) -> Union[bson.Binary, bytes]: ...
    @overload
    def __new__(cls, type_: Type[schema.ObjectId], **kwargs) -> bson.ObjectId: ...
    @overload
    def __new__(cls, type_: schema.ObjectId, **kwargs) -> bson.ObjectId: ...
    @overload
    def __new__(cls, type_: Type[schema.Anything], **kwargs) -> Any: ...
    @overload
    def __new__(cls, type_: schema.Anything, **kwargs) -> Any: ...
    @overload
    def __new__(cls, type_: Type[None], **kwargs) -> Any: ...
    @overload
    def __new__(cls, type_: Type[schema.Deprecated], **kwargs) -> DeprecatedField: ...
    @overload
    def __new__(cls, type_: schema.Deprecated, **kwargs) -> DeprecatedField: ...
    @overload
    def __new__(cls, type_: schema.OneOf, **kwargs) -> Any: ...  # unfortunately I don't think we can be more specific

    # container data structures
    @overload
    def __new__(cls, type_: Type[schema.Array], **kwargs) -> List: ...
    @overload
    def __new__(cls, type_: schema.Array, **kwargs) -> List: ...
    # TODO: typing of elements within an S.Array(str) for example.  make Array a generic?
    # @overload
    # def __new__(cls, type_: schema.Array[str], **kwargs) -> List[str]: ...
    @overload
    def __new__(cls, type_: List, **kwargs) -> List: ...
    @overload
    def __new__(cls, type_: List[Type[AnyType]], **kwargs) -> List[AnyType]: ...
    @overload
    def __new__(cls, type_: Dict, **kwargs) -> Dict: ...

    # repeat all with the actual name first
    #  like Field('thefieldname', str)
    @overload
    def __new__(cls, name: str, type_: Type[schema.String], **kwargs) -> str: ...
    @overload
    def __new__(cls, name: str, type_: schema.String, **kwargs) -> str: ...
    @overload
    def __new__(cls, name: str, type_: Type[str], **kwargs) -> str: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.Int], **kwargs) -> int: ...
    @overload
    def __new__(cls, name: str, type_: schema.Int, **kwargs) -> int: ...
    @overload
    def __new__(cls, name: str, type_: Type[int], **kwargs) -> int: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.Float], **kwargs) -> Union[int, float]: ...
    @overload
    def __new__(cls, name: str, type_: schema.Float, **kwargs) -> Union[int, float]: ...
    @overload
    def __new__(cls, name: str, type_: Type[float], **kwargs) -> float: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.DateTimeTZ], **kwargs) -> datetime: ...
    @overload
    def __new__(cls, name: str, type_: schema.DateTimeTZ, **kwargs) -> datetime: ...
    @overload
    def __new__(cls, name: str, type_: Type[datetime], **kwargs) -> datetime: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.Bool], **kwargs) -> bool: ...
    @overload
    def __new__(cls, name: str, type_: schema.Bool, **kwargs) -> bool: ...
    @overload
    def __new__(cls, name: str, type_: Type[bool], **kwargs) -> bool: ...

    # special
    @overload
    def __new__(cls, name: str, type_: Type[schema.Binary], **kwargs) -> Union[bson.Binary, bytes]: ...
    @overload
    def __new__(cls, name: str, type_: schema.Binary, **kwargs) -> Union[bson.Binary, bytes]: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.ObjectId], **kwargs) -> bson.ObjectId: ...
    @overload
    def __new__(cls, name: str, type_: schema.ObjectId, **kwargs) -> bson.ObjectId: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.Anything], **kwargs) -> Any: ...
    @overload
    def __new__(cls, name: str, type_: schema.Anything, **kwargs) -> Any: ...
    @overload
    def __new__(cls, name: str, type_: Type[None], **kwargs) -> Any: ...
    @overload
    def __new__(cls, name: str, type_: Type[schema.Deprecated], **kwargs) -> DeprecatedField: ...
    @overload
    def __new__(cls, name: str, type_: schema.Deprecated, **kwargs) -> DeprecatedField: ...
    @overload
    def __new__(cls, name: str, type_: schema.OneOf, **kwargs) -> Any: ...  # unfortunately I don't think we can be more specific

    # container data structures
    @overload
    def __new__(cls, name: str, type_: Type[schema.Array], **kwargs) -> List: ...
    @overload
    def __new__(cls, name: str, type_: schema.Array, **kwargs) -> List: ...
    @overload
    def __new__(cls, name: str, type_: List, **kwargs) -> List: ...
    @overload
    def __new__(cls, name: str, type_: List[Type[AnyType]], **kwargs) -> List[AnyType]: ...
    @overload
    def __new__(cls, name: str, type_: Dict, **kwargs) -> Dict: ...


M = TypeVar('M')

MongoFilter = dict
ChangeResult = dict
SaveResult = Union[ObjectId, Any]
class _ClassManager(Generic[M]):
    # proxies these from Session
    def get(self, **kwargs) -> Optional[M]: ...
    def find(self, filter: MongoFilter = None, *args, **kwargs) -> Cursor[M]: ...
    #@overload
    #def find(self, filter: MongoFilter = None, *args, validate: Literal[False], **kwargs) -> Generator[M]: ...
    #@overload
    def find_by(self, filter: MongoFilter, *args, validate: bool = True, **kwargs) -> Cursor[M]: ...
    #@overload
    #def find_by(self, filter: MongoFilter, *args, validate: Literal[False], **kwargs) -> Generator[M]: ...
    def remove(self, spec_or_id: Union[MongoFilter, ObjectId] = None, **kwargs) -> ChangeResult: ...
    def count(self) -> int: ...
    """
    def update_partial(self) -> int: ...
    def group(self) -> int: ...
    def ensure_indexes(self) -> int: ...
    def index_information(self) -> int: ...
    def drop_indexes(self) -> int: ...
    def find_and_modify(self) -> int: ...
    def aggregate(self) -> int: ...
    def distinct(self) -> int: ...
    def map_reduce(self) -> int: ...
    def inline_map_reduce(self) -> int: ...
    """

class _InstanceManager:
    # proxies these from Session
    def save(self, *args: str, **kwargs) -> SaveResult: ...
    def insert(self, **kwargs) -> SaveResult: ...
    def upsert(self, spec_fields: List[str], **kwargs) -> ChangeResult: ...
    def delete(self) -> ChangeResult: ...
    def set(self, fields_values: Mapping[str, Any]) -> ChangeResult: ...
    def increase_field(self, **kwargs) -> None: ...


@type_check_only
class Manager(_ClassManager[M], _InstanceManager): ...


def __getattr__(name) -> Any: ...  # marks file as incomplete